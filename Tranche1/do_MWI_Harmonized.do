


********************************************************************************
********************************************************************************

***********************   **    **  **    **  ********   ***********************
***********************   **    **  **    **  ********   ***********************
***********************   ***  ***  **    **     **      ***********************
***********************   ********  **    **     **      ***********************
***********************   ********  **    **     **      ***********************
***********************   ** ** **  ** ** **     **      ***********************
***********************   **    **  ** ** **     **      ***********************
***********************   **    **  ********     **      ***********************
***********************   **    **  ***  ***  ********   ***********************
***********************   **    **  **    **  ********   ***********************

********************************************************************************
********************************************************************************


********************************************************************************
{	/*	Cover	*/ 
********************************************************************************



dir "${raw_hfps_mwi}", w

d using	"${raw_hfps_mwi}/sect1_interview_info_r1.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r2.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r3.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r4.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r5.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r6.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r7.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r8.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r9.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r10.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r11.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r12.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r13.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r14.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r15.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r16.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r17.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r18.dta"
d using	"${raw_hfps_mwi}/sect1_interview_info_r19.dta"

d using	"${raw_hfps_mwi}/sect12_interview_result_r1.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r2.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r3.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r4.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r5.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r6.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r7.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r8.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r9.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r10.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r11.dta"
// d using	"${raw_hfps_mwi}/sect12_interview_result_r12.dta"
// d using	"${raw_hfps_mwi}/sect12_interview_result_r13.dta"
// d using	"${raw_hfps_mwi}/sect12_interview_result_r14.dta"
// d using	"${raw_hfps_mwi}/sect12_interview_result_r15.dta"
// d using	"${raw_hfps_mwi}/sect12_interview_result_r16.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r17.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r18.dta"
d using	"${raw_hfps_mwi}/sect12_interview_result_r19.dta"

d using	"${raw_hfps_mwi}/sect2_household_roster_r1.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r2.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r3.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r4.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r5.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r6.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r7.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r8.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r9.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r10.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r11.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r12.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r13.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r14.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r15.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r16.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r17.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r18.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r19.dta"

d using	"${raw_hfps_mwi}/secta_cover_page_r1.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r2.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r3.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r4.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r5.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r6.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r7.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r8.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r9.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r10.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r11.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r12.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r13.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r14.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r15.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r16.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r17.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r18.dta"
d using	"${raw_hfps_mwi}/secta_cover_page_r19.dta"


*	get round zero identification information to augment this data
dir "${raw_lsms_mwi}"
u "${raw_lsms_mwi}/hh_mod_a_filt_19.dta", clear
inspect region district ta_code reside 

#d ; 
clear; append using
	"${raw_hfps_mwi}/sect2_household_roster_r1.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r2.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r3.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r4.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r5.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r6.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r7.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r8.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r9.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r10.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r11.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r12.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r13.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r14.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r15.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r16.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r17.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r18.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r19.dta"
, gen(round);
#d cr 
// isid y4 round pid
inspect pid PID
replace pid=PID if mi(pid)
isid y4 round pid
keep y4 round pid s2q5 s2q6
tempfile sexage
sa		`sexage'

#d ; 
clear; append using
	"${raw_hfps_mwi}/sect1_interview_info_r1.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r2.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r3.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r4.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r5.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r6.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r7.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r8.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r9.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r10.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r11.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r12.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r13.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r14.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r15.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r16.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r17.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r18.dta"
	"${raw_hfps_mwi}/sect1_interview_info_r19.dta"
, gen(round);
#d cr
bys y4_hhid round (attempts__id) : keep if _n==_N
isid y4 round


keep y4 round s1q2 s1q9
g pid=s1q9
mer m:1 y4 round pid using `sexage', keep(1 3) nogen

tempfile resp_date
sa		`resp_date'

#d ; 
clear; append using
	"${raw_hfps_mwi}/secta_cover_page_r1.dta"
	"${raw_hfps_mwi}/secta_cover_page_r2.dta"
	"${raw_hfps_mwi}/secta_cover_page_r3.dta"
	"${raw_hfps_mwi}/secta_cover_page_r4.dta"
	"${raw_hfps_mwi}/secta_cover_page_r5.dta"
	"${raw_hfps_mwi}/secta_cover_page_r6.dta"
	"${raw_hfps_mwi}/secta_cover_page_r7.dta"
	"${raw_hfps_mwi}/secta_cover_page_r8.dta"
	"${raw_hfps_mwi}/secta_cover_page_r9.dta"
	"${raw_hfps_mwi}/secta_cover_page_r10.dta"
	"${raw_hfps_mwi}/secta_cover_page_r11.dta"
	"${raw_hfps_mwi}/secta_cover_page_r12.dta"
	"${raw_hfps_mwi}/secta_cover_page_r13.dta"
	"${raw_hfps_mwi}/secta_cover_page_r14.dta"
	"${raw_hfps_mwi}/secta_cover_page_r15.dta"
	"${raw_hfps_mwi}/secta_cover_page_r16.dta"
	"${raw_hfps_mwi}/secta_cover_page_r17.dta"
	"${raw_hfps_mwi}/secta_cover_page_r18.dta"
	"${raw_hfps_mwi}/secta_cover_page_r19.dta"
, gen(round);
#d cr
isid y4 round
mer 1:1 y4 round using `resp_date'
ta result _merge
ta round if result!=1 & _m==3
su wt_p2round3 if result!=1 & _m==3	//	keep these 
su wt_* if _m==1
keep if _m==3
drop _merge 
la drop _append
la val round 
ta round 
	g phase=cond(round<=12,1,2), b(round)	
isid y4_hhid round
	la var round	"Survey round"
	la var phase	"Survey phase"

*	weights
d wt_*	// one weight per round 
tabstat wt_*, by(round) s(sum) format(%12.3gc)
egen wgt = rowfirst(wt_*)
drop wt_*
la var wgt	"Sampling round"

*	dates
li interviewDate s1q2 in 1/10
	convert_date_time interviewDate s1q2
	ta interviewDatermdr
	g fmt1 = cofd(date(interviewDatermdr,"YMD")), a(interviewDate)
	egen pnl_intclock = rowfirst(interviewDate fmt1 s1q2)
	format pnl_intclock %tc
	drop interviewDate interviewDatermdr fmt1 s1q2
	g double pnl_intdate = dofc(pnl_intclock)
	format pnl_intdate %td
	

g long start_yr= Clockpart(pnl_intclock, "year")
g long start_mo= Clockpart(pnl_intclock, "month")
g long start_dy= Clockpart(pnl_intclock, "day")

table (start_yr start_mo) round, nototal


*	admin details (compare with current data captured in the form here )
mer m:1 y4_hhid using "${raw_lsms_mwi}/hh_mod_a_filt_19.dta",  keepus(region district ta_code reside )
ta round if _m==1	//	check how they handled this in the harmonized data as it currently stands 
keep if _m != 2
drop _merge
ren (region district ta_code reside)(r0_region r0_district r0_ta_code r0_reside)
compare r0_region hh_a00
compare r0_district hh_a01
compare r0_reside urb_rural
ta r0_reside urb_rural

isid y4_hhid round
sort y4_hhid round

sa "${local_storage}/tmp_MWI_cover.dta", replace 


*	modifications for construction of grand panel 
u  "${local_storage}/tmp_MWI_cover.dta", clear


egen pnl_hhid = group(y4_hhid)
egen pnl_admin1 = group(hh_a00)
egen pnl_admin2 = group(hh_a01)
egen pnl_admin3 = group(r0_ta_code)

g pnl_urban = urb_rural=="urban":hh_a03b
g pnl_wgt = wgt 

sa "${local_storage}/tmp_MWI_pnl_cover.dta", replace 


********************************************************************************
}	/*	end Cover	*/ 
********************************************************************************


********************************************************************************
{	/*	Demographics	*/ 
********************************************************************************



dir "${raw_hfps_mwi}", w

d using	"${raw_hfps_mwi}/sect2_household_roster_r1.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r2.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r3.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r4.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r5.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r6.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r7.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r8.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r9.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r10.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r11.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r12.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r13.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r14.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r15.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r16.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r17.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r18.dta"
d using	"${raw_hfps_mwi}/sect2_household_roster_r19.dta"


#d ;
u "${raw_hfps_mwi}/sect2_household_roster_r1" , clear;
d, replace clear;
ren (position type isnumeric format vallab varlab)(pos1 type1 isnum1 fmt1 val1 var1);
tempfile base;
sa      `base';
foreach r of numlist 2(1)19 {;
	u "${raw_hfps_mwi}/sect2_household_roster_r`r'.dta" , clear;
	d, replace clear;
	ren (position type isnumeric format vallab varlab)(pos`r' type`r' isnum`r' fmt`r' val`r' var`r');
	tempfile r`r';
	sa      `r`r'';
	u `base', clear;
	mer 1:1 name using `r`r'', gen(_`r');
	sa `base', replace ;
};
u `base', clear;
#d cr 
egen matches = anycount(_*), v(3)
ta matches
ta name matches if matches>=16
ta name matches if matches<16

levelsof name if matches>=16, clean
li name var1 if matches>=16, sep(0)
li name _* if matches<16, sep(0) nol


*	get round zero identification information to augment this data

#d ; 
clear; append using
	"${raw_hfps_mwi}/sect2_household_roster_r1.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r2.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r3.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r4.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r5.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r6.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r7.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r8.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r9.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r10.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r11.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r12.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r13.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r14.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r15.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r16.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r17.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r18.dta"
	"${raw_hfps_mwi}/sect2_household_roster_r19.dta"
, gen(round); la drop _append; la val round; 
#d cr 
// isid y4 round pid
inspect pid PID
compare pid PID
replace pid=PID if mi(pid)
isid y4 round pid


		tabstat s2q2 s2q3 s2q5 s2q6 s2q7, by(round) s(n)
	     gen member=(s2q2==1|s2q3==1)
		 gen sex=s2q5
		 gen age=s2q6
	     gen head=(s2q7==1|s2q9==1)
	     gen relation=s2q7 
		 replace relation=s2q9 if relation==. & s2q9!=.
		 label copy s2q7 relation
		 label val relation relation	
		 replace relation=. if member!=1
		 replace head=0 if member!=1			 
		 gen relation_os=s2q7_os  if relation==16
		 replace relation_os=s2q9_os if relation_os=="" & relation==16

		*	respondent
	  d using "${local_storage}/tmp_MWI_cover.dta"
	  mer 1:1 y4_hhid round pid using "${local_storage}/tmp_MWI_cover.dta", keepus(s1q9 y4_hhid round pid result)
	  la val _merge
	  ta round _m, m
	  ta result _m, m
	  
	  bys y4_hhid round (pid) : egen _m2 = max(_m==2)
	  li y4 round pid s1q9 _me if _m2==1, sepby(y4)	//	 quite a few cases of missing pid leading to _m==2
	  keep if inlist(_me,1,3)
	  g respond =(_me==3)
	  
		 bys y4_hhid round (pid) : egen testresp = sum(respond)
		ta round testresp,m	//	widely distributed, no especially high rounds, only two zero 
		ta respond member,m
		
		*	step 1 assume prior round respondent was interviewed again if available 
		bys y4_hhid pid (round) : replace respond = respond[_n-1] if testresp!=1 & member==1 & !mi(respond[_n-1])	//	presume that the respondent id is stable if that person is still available 

		bys y4_hhid round (pid) : egen testresp2 = sum(respond)
		ta round testresp2,m	//	round 1 most pronounced
		li y4_hhid round pid member respond if testresp2==0, sepby(hhid)
		by y4_hhid : egen flagresp = min(testresp2)
		li y4_hhid round pid member respond age sex testresp2 if flagresp==0, sepby(y4_hhid)
		li y4_hhid round pid member respond if flagresp==0 & (respond==1 | testresp2==0), sepby(y4_hhid)

	*	step 2 use respondent from subsequent round 
		su round, meanonly
		g backwards = -1 * (round-r(max)-r(min))
		bys y4_hhid pid (backwards) : replace respond = respond[_n-1] if testresp2!=1 & member==1 & !mi(respond[_n-1])	//	presume that the respondent id is stable if that person is still available 
		*	also code=1 if any singletons exist 
		bys y4_hhid round (pid) : replace respond =1 if testresp2!=1 & _N==1	//	9
			
		
		bys y4_hhid round (pid) : egen testresp3 = sum(respond)
		ta round testresp3
		by y4_hhid : egen flagresp2 = min(testresp3)
		li y4_hhid round pid member respond age sex relation testresp3 if flagresp2==0, sepby(y4_hhid)
		li y4_hhid round pid member respond age sex relation if flagresp2==0 & (respond==1 | testresp3==0), sepby(y4_hhid)
	  
	*	step 3 manual decision-making
		*	cases where we will take the head
		recode respond 0=1 if y4_hhid=="2476-002" & round==14 & relation==1
		recode respond 0=1 if y4_hhid=="2424-001" & round==1 & relation==1
		recode respond 0=1 if y4_hhid=="0933-003" & round==14 & relation==1
	  *	can't really resolve the remainder 
	  drop testresp-flagresp2

		*	fill in with prior round information where possible
		foreach x in age sex relation {
			tempvar maxmiss maxnmiss minnmiss modenmiss fillmiss 
		bys y4_hhid pid (round) : egen `maxmiss'= max(mi(`x'))
		by  y4_hhid pid (round) : egen `maxnmiss'= max(`x')
		by  y4_hhid pid (round) : egen `minnmiss'= min(`x')
		by  y4_hhid pid (round), rc0 : egen `modenmiss'= mode(`x')
		
		g `fillmiss' = `maxnmiss' if `maxmiss'==1 & `maxnmiss'==`minnmiss'
		replace `fillmiss' = `modenmiss' if mi(`fillmiss') & `maxnmiss'==1
		su `x' if `maxmiss'==1
		replace `x' = `fillmiss' if mi(`x') & !mi(`fillmiss')
		su `x' if `maxmiss'==1
		
		drop `maxmiss' `maxnmiss' `minnmiss' `modenmiss' `fillmiss' 
			}
		
	  
	  *	drop unnecessary variables 
	  keep y4 pid round member-relation_os respond
	  isid y4 pid round
	  sort y4 pid round
	  sa "${local_storage}/tmp_MWI_ind.dta", replace
	  
	  
*	use individual panel to make demographics 
u "${local_storage}/tmp_MWI_ind.dta", clear

*	respondent characteristics
foreach x in sex age head relation {
	bys y4_hhid round (pid) : egen resp_`x' = max(`x' * cond(respond==1,1,.))
}


*	do we still have a respondent and a head for all
bys y4_hhid round (pid) : egen headtest = sum(head) 
bys y4_hhid round (pid) : egen resptest = sum(respond) 
bys y4_hhid round (pid) : egen memtest = sum(member) 
tab1 *test,m


keep if member==1
	  


g hhsize=1
*	assume all missing ages are labor age 
g m0_14 	= (sex==1 & inrange(age,0,14))
g m15_64	= (sex==1 & (inrange(age,15,64) | mi(age)))
g m65		= (sex==1 & (age>64 & !mi(age)))
g f0_14 	= (sex==2 & inrange(age,0,14))
g f15_64	= (sex==2 & (inrange(age,15,64) | mi(age)))
g f65		= (sex==2 & (age>64 & !mi(age)))

		    g		adulteq=. 
            replace adulteq = 0.27 if (sex==1 & age==0) 
            replace adulteq = 0.45 if (sex==1 & inrange(age,1,3)) 
            replace adulteq = 0.61 if (sex==1 & inrange(age,4,6)) 
            replace adulteq = 0.73 if (sex==1 & inrange(age,7,9)) 
            replace adulteq = 0.86 if (sex==1 & inrange(age,10,12)) 
            replace adulteq = 0.96 if (sex==1 & inrange(age,13,15)) 
            replace adulteq = 1.02 if (sex==1 & inrange(age,16,19)) 
            replace adulteq = 1.00 if (sex==1 & age >=20) 	//	assumes all missing ages are adults 
            replace adulteq = 0.27 if (sex==2 & age ==0) 
            replace adulteq = 0.45 if (sex==2 & inrange(age,1,3)) 
            replace adulteq = 0.61 if (sex==2 & inrange(age,4,6)) 
            replace adulteq = 0.73 if (sex==2 & inrange(age,7,9)) 
            replace adulteq = 0.78 if (sex==2 & inrange(age,10,12)) 
            replace adulteq = 0.83 if (sex==2 & inrange(age,13,15)) 
            replace adulteq = 0.77 if (sex==2 & inrange(age,16,19)) 
            replace adulteq = 0.73 if (sex==2 & age >=20)   
			su adulteq
	        collapse (sum) hhsize-adulteq (firstnm) resp_*, by(y4_hhid round)	

sa "${local_storage}/tmp_MWI_demog.dta", replace
 

********************************************************************************
}	/*	Demographics end	*/ 
********************************************************************************


********************************************************************************
{	/*	Employment	*/ 
********************************************************************************

dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*employment*", w
dir "${raw_hfps_mwi}/*nfe*", w

d using	"${raw_hfps_mwi}/sect6_employment_r1.dta"
d using	"${raw_hfps_mwi}/sect6a_employment1_r2.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r2.dta"
d using	"${raw_hfps_mwi}/sect6a_employment1_r3.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r3.dta"
d using	"${raw_hfps_mwi}/sect6a_employment1_r4.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r4.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r5.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r6.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r7.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r8.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r9.dta"
// d using	"${raw_hfps_mwi}/sect6a_employment_r10.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r11.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r12.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r13.dta"
d using	"${raw_hfps_mwi}/sect6a_employment2_r14.dta"
// d using	"${raw_hfps_mwi}/sect6a_employment_r15.dta"
d using	"${raw_hfps_mwi}/sect6_employment_r16.dta"
d using	"${raw_hfps_mwi}/sect6_employment_r17.dta"
d using	"${raw_hfps_mwi}/sect6_employment_r18.dta"
d using	"${raw_hfps_mwi}/sect6_employment_r19.dta"

*	non-farm enterprise 
d using	"${raw_hfps_mwi}/sect6b_nfe_r2.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r3.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r4.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r5.dta"
// d using	"${raw_hfps_mwi}/sect6b_nfe_r6.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r7.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r8.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r9.dta"
// d using	"${raw_hfps_mwi}/sect6b_nfe_r10.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r11.dta"
d using	"${raw_hfps_mwi}/sect6b_nfe_r12.dta"

*	how to deal with the split modules in r2-4

d using	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", si
d using	"${raw_hfps_mwi}/sect6a_employment2_r2.dta", si


*	check sector labels 
u	"${raw_hfps_mwi}/sect6_employment_r1.dta", clear
uselabel s6q5, clear
tempfile r1
sa		`r1'
u	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", clear
ta s6q4c_1 s6q5_1,m
uselabel s6q5_1, clear
tempfile r2a
sa		`r2a'
u	"${raw_hfps_mwi}/sect6a_employment2_r2.dta", clear
uselabel s6q5, clear
tempfile r2b
sa		`r2b'
u	"${raw_hfps_mwi}/sect6a_employment1_r3.dta", clear
uselabel s6q5_1, clear
tempfile r3a
sa		`r3a'
u	"${raw_hfps_mwi}/sect6a_employment2_r3.dta", clear
uselabel s6q5, clear
tempfile r3b
sa		`r3b'
u	"${raw_hfps_mwi}/sect6a_employment1_r4.dta", clear
uselabel s6q5_1, clear
tempfile r4a
sa		`r4a'
u	"${raw_hfps_mwi}/sect6a_employment2_r4.dta", clear
uselabel s6q5, clear
tempfile r4b
sa		`r4b'
u	"${raw_hfps_mwi}/sect6a_employment2_r5.dta", clear
uselabel s6q5, clear
tempfile r5
sa		`r5'
u	"${raw_hfps_mwi}/sect6a_employment2_r6.dta", clear
uselabel s6q5, clear
tempfile r6
sa		`r6'
u	"${raw_hfps_mwi}/sect6a_employment2_r7.dta", clear
uselabel s6q5, clear
tempfile r7
sa		`r7'
u	"${raw_hfps_mwi}/sect6a_employment2_r8.dta", clear
uselabel s6q5, clear
tempfile r8
sa		`r8'
u	"${raw_hfps_mwi}/sect6a_employment2_r9.dta", clear
uselabel s6q5, clear
tempfile r9
sa		`r9'
u	"${raw_hfps_mwi}/sect6a_employment2_r11.dta", clear
uselabel s6q5, clear
tempfile r11
sa		`r11'
u	"${raw_hfps_mwi}/sect6a_employment2_r12.dta", clear
uselabel s6q5, clear
tempfile r12
sa		`r12'
u	"${raw_hfps_mwi}/sect6a_employment2_r13.dta", clear
uselabel s6q5b, clear
tempfile r13
sa		`r13'
u	"${raw_hfps_mwi}/sect6a_employment2_r14.dta", clear
uselabel s6q5b, clear
tempfile r14
sa		`r14'
u	"${raw_hfps_mwi}/sect6_employment_r16.dta", clear	//	none
u	"${raw_hfps_mwi}/sect6_employment_r17.dta", clear	//	none
u	"${raw_hfps_mwi}/sect6_employment_r18.dta", clear
uselabel s6q5b, clear
tempfile r18
sa		`r18'

u `r1', clear
foreach i in 2a 2b 3a 3b 4a 4b 5 6 7 8 9 11 12 13 14 {
mer 1:1 lname value label using `r`i'', gen(_`i')
}
egen matches = anycount(_? _??), v(3)
ta matches

sort value label lname
li lname value label matches, sepby(value)
li lname value label _*, sepby(value) nol

*	will implement this here as a one-off 
u	"${raw_hfps_mwi}/sect6_employment_r1.dta", clear
la li s6q5
u	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", clear
la li s6q5_1
recode s6q5_1 (1 15=1)(2 3=2)(5=3)(6=4)(7=6)(8 14=5)(9=7)(10/12=9)(13 16 96=8), gen(emp_sector)

u	"${raw_hfps_mwi}/sect6a_employment2_r13.dta", clear
la li s6q5b	//	this is reconciled with the 9-code NGA codes



*	check sector labels 
u	"${raw_hfps_mwi}/sect6_employment_r1.dta", clear
ds , has(varl "*reason you stopped working*") detail
uselabel s6q3a, clear
tempfile r1
sa		`r1'
u	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", clear
ds , has(varl "*reason you stopped working*") detail
uselabel s6q3a_1, clear
tempfile r2a
sa		`r2a'
u	"${raw_hfps_mwi}/sect6a_employment2_r2.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r2b
sa		`r2b'
u	"${raw_hfps_mwi}/sect6a_employment1_r3.dta", clear
ds , has(varl "*reason you stopped working*") detail
uselabel s6q3a_1, clear
tempfile r3a
sa		`r3a'
u	"${raw_hfps_mwi}/sect6a_employment2_r3.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r3b
sa		`r3b'
u	"${raw_hfps_mwi}/sect6a_employment1_r4.dta", clear
ds , has(varl "*reason you stopped working*") detail
uselabel s6q3a_1, clear
tempfile r4a
sa		`r4a'
u	"${raw_hfps_mwi}/sect6a_employment2_r4.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r4b
sa		`r4b'
u	"${raw_hfps_mwi}/sect6a_employment2_r5.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r5
sa		`r5'
u	"${raw_hfps_mwi}/sect6a_employment2_r6.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r6
sa		`r6'
u	"${raw_hfps_mwi}/sect6a_employment2_r7.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r7
sa		`r7'
u	"${raw_hfps_mwi}/sect6a_employment2_r8.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r8
sa		`r8'
u	"${raw_hfps_mwi}/sect6a_employment2_r9.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r9
sa		`r9'
u	"${raw_hfps_mwi}/sect6a_employment2_r11.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r11
sa		`r11'
u	"${raw_hfps_mwi}/sect6a_employment2_r12.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r12
sa		`r12'
u	"${raw_hfps_mwi}/sect6a_employment2_r13.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r13
sa		`r13'
u	"${raw_hfps_mwi}/sect6a_employment2_r14.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r14
sa		`r14'
u	"${raw_hfps_mwi}/sect6_employment_r18.dta", clear
ds , has(varl "*reason you stopped working*") detail
// uselabel s6q3a, clear
ds , has(varl "Why did you not work last week*") detail
d `r(varlist)', replace clear
tempfile r18
sa		`r18'

*	single select results
u `r1', clear
foreach i in 2a 3a 4a {
mer 1:1 lname value label using `r`i'', gen(_`i')
}
egen matches = anycount(_?a), v(3)
ta matches

sort value label lname
li lname value label matches, sepby(value)
li lname value label _*, sepby(value) nol

*	multi select results
qui {
u `r2b', clear
foreach i in 3b 4b 5 6 7 8 9 11 12 13 14 18 {
mer 1:1 name varlab using `r`i'', gen(_`i')
}
egen matches = anycount(_? _?b), v(3)
ta matches
}
sort name varlab
li name varlab matches, sep(0)




*	how to deal with the split modules in r2-4

d using	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", si
d using	"${raw_hfps_mwi}/sect6a_employment2_r2.dta", si

#d ; 
forv r=2/4 {;
	u "${raw_hfps_mwi}/sect6a_employment1_r`r'.dta", clear;
	mer 1:1 y4_hhid using "${raw_hfps_mwi}/sect6a_employment2_r`r'.dta", assert(3) nogen;
	mer 1:1 y4_hhid using "${raw_hfps_mwi}/sect6b_nfe_r`r'.dta", assert(3) nogen;
	tempfile r`r';
	sa `r`r'';
};
foreach r of numlist 5 7/9 11 12 {; 
	u "${raw_hfps_mwi}/sect6a_employment2_r`r'.dta", clear;
	mer 1:1 y4_hhid using "${raw_hfps_mwi}/sect6b_nfe_r`r'.dta", assert(3) nogen;
	tempfile r`r';
	sa `r`r'';
};
clear; append using
	"${raw_hfps_mwi}/sect6_employment_r1.dta"
	`r2'
	`r3'
	`r4'
	`r5'
	"${raw_hfps_mwi}/sect6a_employment2_r6.dta"
	`r7'
	`r8'
	`r9'

	`r11'
	`r12'
	"${raw_hfps_mwi}/sect6a_employment2_r13.dta"
	"${raw_hfps_mwi}/sect6a_employment2_r14.dta"

	"${raw_hfps_mwi}/sect6_employment_r16.dta"
	"${raw_hfps_mwi}/sect6_employment_r17.dta"
	"${raw_hfps_mwi}/sect6_employment_r18.dta"
, gen(round);
#d cr 
isid y4 round
la drop _append
la val round 
ta round 
replace round=round+1 if round>9
replace round=round+1 if round>14
ta round
	la var round	"Survey round"

	
	tab2 round *_case, first m
d
ds s6*, not(type string)
tabstat `r(varlist)', by(round) s(n)

ta round s6q1,m 
ta s6q6 round,m
ta s6q6 s6q1, m
	
g work_cur = (s6q1==1) if inlist(s6q1,1,2)
g nwork_cur=1-work_cur

g wage_cur = (s6q1==1 & inlist(s6q6,4,5)) if inlist(s6q1,1,2)
g biz_cur  = (s6q1==1 & inlist(s6q6,1,2)) if inlist(s6q1,1,2)
g farm_cur = (s6q1==1 & inlist(s6q6,3))   if inlist(s6q1,1,2)
la var work_cur		"Respondent currently employed"
la var nwork_cur	"Respondent currently unemployed"
la var wage_cur		"Respondent mainly employed for wages"
la var biz_cur		"Respondent mainly employed in household enterprise"
la var farm_cur		"Respondent mainly employed on family farm"
	
*	reason for stopping working
d s6q3a
ds , has(varl "*reason you stopped working*") detail
tabstat `r(varlist)', by(round) s(n)
la li s6q3a s6q3a_1	
tab2 round s6q3a s6q3a_1, first
ds , has(varl "Why did you not work last week*") detail
tabstat `r(varlist)', by(round) s(n)
la li s6q1c 	//	4 add'l codes were added 
ta round if !mi(s6q1c)

foreach i of numlist 1/13 96 {
	egen nwork_why_`i'_cur = rowmax(s6q1c__`i' s6q3__`i')
	replace nwork_why_`i'_cur = (s6q1c==`i') if inlist(round,13,14,18) & !mi(s6q1c)
	if `i'!=13 {
	replace nwork_why_`i'_cur = (s6q3a==`i') if inlist(round,1) & !mi(s6q3a)
	}
	}
forv i=14/18 { 
	g nwork_why_`i'_cur = (s6q1c==`i') if inlist(round,13,14,18) & !mi(s6q1c)
}

g		nwork_why_lab_cur=.
la var	nwork_why_lab_cur	"Not working currently because [...]"
foreach i of numlist 1/18 96 {
	loc lbl = strupper(substr("`: label s6q1c `i''",1,1)) + strlower(substr("`: label s6q1c `i''",2,length("`: label s6q1c `i''")-1))
	la var nwork_why_`i'_cur	"`lbl'"
}
	
*	sector
d s6q5*
la li  s6q5 s6q4c_1 s6q5_1 s6q5b
tab2 round s6q5 s6q5_1 s6q5b , first m
recode s6q5 s6q5_1 (1 15=1)(2 3=2)(5=3)(6=4)(7=6)(8 14=5)(9=7)(10/12=9)(13 16 96=8), gen(sctr1 sctr2)
egen sector_cur = rowfirst(sctr1 sctr2 s6q5b)
run "${hfps_github}/label_emp_sector.do"
la val sector_cur emp_sector
ta sector_cur round, m

*	hours
ds, has(varl *hour* *HOUR* *Hour*) detail 

d s6q8b1
g hours_cur = s6q8b1
la var hours_cur	"Hours respondent worked in current employment"


*	NFE
tab2 round s6q11 s6bq11, first
g		refperiod_nfe = (s6q11==1) if round==1
replace	refperiod_nfe = (s6bq11==1) if round>1
la var	refperiod_nfe "Household operated a non-farm enterprise (NFE) since previous contact"

*	activity 
d s6bq11c	//	this is just a string, not particularly usefu

*	sector 
tab2 round s6q12 s6qb12, m first
la li s6q12 s6qb12
egen sector_nfe = rowfirst(s6q12 s6qb12)
recode sector_nfe (1 15=1)(2 3=2)(5=3)(6=4)(7=6)(8 14=5)(9=7)(10/12=9)(13 16 96=8)
la val sector_nfe emp_sector
la var sector_nfe	"Sector of NFE"
ta sector_nfe round,m

*	currently operational
tab2 round s6q13 s6bq11a_?, first m	
la li s6q13 s6bq11a_1 s6bq11a_2 s6bq11a_3	//	s6q13 is too much of a stretch
compare s6bq11a_1 s6bq11a_2	//	none jointly defined
compare s6bq11a_3 s6bq11a_2	//	several are jointly defined, but mostly exclusive 
egen status_nfe = rowfirst(s6bq11a_1 s6bq11a_2 s6bq11a_3)
la copy s6bq11a_1 status_nfe
la val status_nfe status_nfe
la var status_nfe	"Current operational status of NFE"
g open_nfe = (status_nfe==1) if !mi(status_nfe)
la var open_nfe		"NFE is currently open"


	
*	reason for low revenue
tab2 round s6q14 s6qb14, first 
la li  s6q14 s6qb14	//	identical
// 	*-> these were single-select. Just exporting the categorical variable 
// egen lowrev_why_nfe = rowfirst(s6q14 s6qb14)
// la copy s6q14 lowrev_why_nfe
// la val lowrev_why_nfe closed_why_nfe
// la var lowrev_why_nfe	"Reason NFE revenue was low"

*	don't have "events experienced"

*	challenges faced
d s6qb15__*
tab2 round s6qb15__1 s6qb15__2 s6qb15__3 s6qb15__4 s6qb15__5 s6qb15__6 s6qb15__7, first m
g challenge_lbl_nfe = .
la var challenge_lbl_nfe	"Challenges to NFE [...]"
forv i=1/7 {
	loc v s6qb15__`i'
	g challenge`i'_nfe = (`v'==1) if !mi(`v')
	loc lbl = subinstr("`: var lab `v''","Challenges faced: ","",1)
	la var challenge`i'_nfe "`lbl'"
}
tabstat challenge*_nfe, by(round)	




keep y4_hhid round *_cur *_nfe
	
sa "${local_storage}/tmp_MWI_employment.dta", replace 

********************************************************************************
}	/*	Employment end	*/ 
********************************************************************************


********************************************************************************
{	/*	FIES	*/ 
********************************************************************************

dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*_food_security_*", w

d using	"${raw_hfps_mwi}/sect8_food_security_r1.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r2.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r3.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r4.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r5.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r6.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r7.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r8.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r9.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r10.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r11.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r12.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r13.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r14.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r15.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r16.dta"
// d using	"${raw_hfps_mwi}/sect8_food_security_r17.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r18.dta"
d using	"${raw_hfps_mwi}/sect8_food_security_r19.dta"



#d ; 
clear; append using
	"${raw_hfps_mwi}/sect8_food_security_r1.dta"
	"${raw_hfps_mwi}/sect8_food_security_r2.dta"
	"${raw_hfps_mwi}/sect8_food_security_r3.dta"

	"${raw_hfps_mwi}/sect8_food_security_r5.dta"
	"${raw_hfps_mwi}/sect8_food_security_r6.dta"
	"${raw_hfps_mwi}/sect8_food_security_r7.dta"
	"${raw_hfps_mwi}/sect8_food_security_r8.dta"
	"${raw_hfps_mwi}/sect8_food_security_r9.dta"
	
	"${raw_hfps_mwi}/sect8_food_security_r11.dta"
	"${raw_hfps_mwi}/sect8_food_security_r12.dta"

	

	"${raw_hfps_mwi}/sect8_food_security_r16.dta"
	
	"${raw_hfps_mwi}/sect8_food_security_r18.dta"
	"${raw_hfps_mwi}/sect8_food_security_r19.dta"
, gen(round);
#d cr
isid y4 round
replace round=round+1 if round>3
replace round=round+1 if round>9
replace round=round+3 if round>12
replace round=round+1 if round>16
la drop _append
la val round 
ta round


la li s8q1 s8q2 s8q3 s8q4 s8q5 s8q6 s8q7 s8q8
tab2 round s8q1 s8q2 s8q3 s8q4 s8q5 s8q6 s8q7 s8q8, first m
g worried	= s8q1==1 if inlist(s8q1,1,2)
g healthy	= s8q2==1 if inlist(s8q2,1,2)
g fewfood	= s8q3==1 if inlist(s8q3,1,2)
g skipped	= s8q4==1 if inlist(s8q4,1,2)
g ateless	= s8q5==1 if inlist(s8q5,1,2)
g runout	= s8q6==1 if inlist(s8q6,1,2)
g hungry	= s8q7==1 if inlist(s8q7,1,2)
g whlday	= s8q8==1 if inlist(s8q8,1,2)
nmissing worried-whlday

*	get weight and hhsize vars 
d using "${local_storage}/tmp_MWI_cover.dta"
mer 1:1 y4 round using "${local_storage}/tmp_MWI_cover.dta", keepus(result urb_rural r0_reside wgt) assert(2 3) keep(3) nogen
mer 1:1 y4 round using "${local_storage}/tmp_MWI_demog.dta", keepus(hhsize) keep(1 3) nogen

*	in some cases, the reference group is "adults in the household" rather than the full household
g wgt_hh = hhsize * wgt

egen RS = rowtotal(worried healthy fewfood skipped ateless runout hungry whlday), m
ta RS, m
recode RS (nonm=.) if mi(worried,healthy,fewfood,skipped,ateless,runout,hungry,whlday)
ta RS round,m

g na="NA" 
g urban = (urb_rural=="urban":hh_a03b)

ta round if !mi(wgt_hh) & !mi(RS)

cap : erase "${local_storage}/FIES_MWI_in.csv"
export delim worried healthy fewfood skipped ateless runout hungry whlday wgt wgt_hh urban round	/*
*/	if /*!mi(RS) &*/ !mi(wgt) & !mi(wgt_hh) using "${local_storage}/FIES_MWI_in.csv", delim(",")
/*	notes on process done in Shiny app
	1	All infit inrange(0.7,1.3), 
	2	Equating: Worried is far above (0.85) global standard, skipped far below (0.66)
		step 1 drop worried=>	skipped low at 0.50
		step 2 drop skipped=>	hungry low at 0.47
		step 3 drop hungry=>	Remainder are all <=.35
		 
	3	downloaded and saved as FIES_MWI_out.csv
*/

/*	when using all, individual level (note that here "region" = survey round)
Prevalence rates of food insecurity by region (% of individuals)
Moderate or Severe	MoE	Severe	MoE
1	72.57	5.03	25.33	4.79
2	68.44	5.43	21.97	4.59
3	67.91	5.52	22.95	4.82
5	62.73	5.62	17.51	3.80
6	67.60	5.45	23.21	4.50
7	64.99	5.98	24.03	4.57
8	68.65	5.67	25.09	4.69
9	58.96	6.12	16.48	4.13
11	48.42	5.98	9.71	3.38
12	46.52	5.95	10.91	3.81
16	77.98	5.56	31.61	5.36
18	68.58	5.81	21.49	4.63
19	84.79	6.47	38.90	7.40
*/
				/*	ARCHIVE: notes on process done in Shiny app
					1	All infit inrange(0.7,1.3), 
					2	Equating: Worried is far above (0.85) global standard, skipped far below (0.67)
						step 1 drop worried=>	skipped low at 0.51
						step 2 drop skipped=>	hungry low at 0.47
						step 3 drop hungry=>	Remainder are all <=.35
						
					3	downloaded and saved as FIES_MWI_out.csv
				*/
				
				/*	when using all, individual level (note that here "region" = survey round)
				Prevalence rates of food insecurity by region (% of individuals)
					Moderate or Severe	MoE	Severe	MoE
				1	72.58	5.03	25.25	4.76
				2	68.44	5.43	21.92	4.57
				3	67.91	5.52	22.90	4.79
				5	62.74	5.62	17.48	3.78
				6	67.61	5.45	23.15	4.48
				7	65.00	5.98	23.97	4.54
				8	68.65	5.67	25.03	4.66
				9	58.97	6.12	16.45	4.11
				11	48.43	5.98	9.69	3.36
				12	46.53	5.95	10.88	3.79
				16	77.99	5.56	31.53	5.32
				18	68.59	5.81	21.44	4.60
				*/

levelsof round, loc(rounds)
foreach r of local rounds {
// 	loc r=19
	cap : erase "${local_storage}/FIES_MWI_r`r'_in.csv"
export delim worried healthy fewfood skipped ateless runout hungry whlday wgt wgt_hh urban na	/*
*/	if round==`r' & !mi(wgt) & !mi(wgt_hh) using "${local_storage}/FIES_MWI_r`r'_in.csv", delim(",")
}



/*
round 1 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r1_out.csv

round 2 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r2_out.csv

round 3 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r3_out.csv

round 5 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r5_out.csv

round 6 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r6_out.csv

round 7 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r7_out.csv

round 8 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r8_out.csv

round 9 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r9_out.csv

round 11 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r11_out.csv

round 12 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r12_out.csv

round 16 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r16_out.csv

round 18 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Remainder all <=0.35
	3	downloaded and saved as FIES_MWI_r18_out.csv

round 19 
	1	All infit inrange(0.7,1.3)
	2	Followed panel finding -> drop worried, skipped, hungry. Ateless is low at 0.39, others all <=0.35
	3	downloaded and saved as FIES_MWI_r19_out.csv


*/





*	merge the downloaded files back in 
	preserve
tempfile out
import delimited using "${local_storage}/FIES_MWI_out.csv", varn(1) clear
ds rawscore /*rawscorepar rawscoreparerr*/ probmod_sev probsev, has(type string)
if length("`r(varlist)'")>0 {
destring rawscore /*rawscorepar rawscoreparerr*/ probmod_sev probsev, replace ignore("NA")
	}
ren (rawscore /*rawscorepar rawscoreparerr*/ probmod_sev probsev)(RS fies_mod fies_sev)
keep RS fies_mod fies_sev
duplicates drop
isid RS, missok
sa `out'
	restore
mer m:1 RS using `out', assert(3) nogen

tabstat fies_mod fies_sev [aw=wgt_hh], by(round)

la var fies_mod	"Probability of moderate + severe food insecurity"
la var fies_sev	"Probability of severe food insecurity"
 
ren fies_??? fies_pooled_???


	preserve 
levelsof round if !mi(RS), loc(rounds)
loc toappend ""
foreach r of local rounds {
import delimited using "${local_storage}/FIES_MWI_r`r'_out.csv", varn(1) clear
ds rawscore probmod_sev probsev, has(type string)
if length("`r(varlist)'")>0 {
destring rawscore probmod_sev probsev, replace ignore("NA")
	}
ren (rawscore probmod_sev probsev)(RS fies_mod fies_sev)
keep RS fies_mod fies_sev
duplicates drop
g round=`r'
tempfile r`r'
sa		`r`r''
loc toappend "`toappend' `r`r''"
}
clear
append using `toappend'
ta round RS
tempfile tomerge 
sa		`tomerge'
	restore

mer m:1 RS round using `tomerge', assert(3) nogen

la var fies_mod	"Probability of moderate + severe food insecurity"
la var fies_sev	"Probability of severe food insecurity"
 
tabstat fies_mod fies_sev fies_pooled_mod fies_pooled_sev [aw=wgt_hh], by(round) format(%9.3f)

la var worried	"Worried about not having enough food to eat"
la var healthy	"Unable to eat healthy and nutritious/preferred foods"
la var fewfood	"Ate only a few kinds of foods"
la var skipped	"Had to skip a meal"
la var ateless	"Ate less than you thought you should"
la var runout	"Ran out of food"
la var hungry	"Were hungry but did not eat"
la var whlday	"Went without eating for a whole day"

ren (worried healthy fewfood skipped ateless runout hungry whlday)	/*
*/	(fies_worried fies_healthy fies_fewfood fies_skipped fies_ateless fies_runout fies_hungry fies_whlday)

ren RS fies_rawscore
la var fies_rawscore	"Food Insecurity Experience Scale - Raw Score"

keep round y4_hhid fies_*
sa "${local_storage}/tmp_MWI_FIES.dta", replace
	
	
	



********************************************************************************
}	/*	FIES end	*/ 
********************************************************************************


********************************************************************************
{	/*	Dietary Diversity	*/ 
********************************************************************************

********************************************************************************
}	/*	Dietary Diversity end	*/ 
********************************************************************************


********************************************************************************
{	/*	Shocks / Coping	*/ 
********************************************************************************


dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*coping*", w

d using	"${raw_hfps_mwi}/sect10_coping_r2.dta"
d using	"${raw_hfps_mwi}/sect10_coping_r3.dta"
d using	"${raw_hfps_mwi}/sect10_coping_r7.dta"
d using	"${raw_hfps_mwi}/sect10_coping_r15.dta"	//	coping matches NG code
d using	"${raw_hfps_mwi}/sect10_coping_r16.dta"	//	alternate coping codes
d using	"${raw_hfps_mwi}/sect10_coping_r18.dta"	//	coping matches NG code

*	set up an automated verification of the coping codes
foreach r of numlist 2 3 7 15 18 {
	u s10q3__* using "${raw_hfps_mwi}/sect10_coping_r2.dta", clear
	d, replace clear
	keep name varlab
	ren varlab varlab`r'
	tempfile r`r'
	sa		`r`r''
}
u `r2', clear
foreach r of numlist 3 7 15 18 {
mer 1:1 name using `r`r'', assert(3) gen(_`r')
assert varlab`r'==varlab2
}
sort name
g code = substr(name,length("s10q3__")+1,length(name)-length("s10q3__"))
destring code, replace
sort code
g varlab = substr(varlab2,strpos(varlab2,":")+1,length(varlab2)-strpos(varlab2,":"))
li name code varlab, sep(0)

d s10q8__* using	"${raw_hfps_mwi}/sect10_coping_r16.dta"	//	alternate coping codes



u	"${raw_hfps_mwi}/sect10_coping_r2.dta"	, clear
la li Sec10_shocks__id
u	"${raw_hfps_mwi}/sect10_coping_r3.dta"	, clear
la li Sec10_shocks__id
u	"${raw_hfps_mwi}/sect10_coping_r7.dta"	, clear
la li Sec10_shocks__id
u	"${raw_hfps_mwi}/sect10_coping_r15.dta"	, clear
la li Sec10_shocks__id
u	"${raw_hfps_mwi}/sect10_coping_r16.dta"	, clear
la li Sec10_shocks__id
u	"${raw_hfps_mwi}/sect10_coping_r18.dta"	, clear	//	matches NG code
la li Sec10_shocks__id

u	"${raw_hfps_mwi}/sect10_coping_r16.dta"	, clear
la li selection

g  s10q3__1 =  s10q8__3
egen  s10q3__6 = rowmax(s10q8__4 s10q8__5)	//	combining add'l income activities with renting out more things 
// g  s10q3__7 =  s10q8__ //	can't link assistance or loans as they are binned in round 16
// g  s10q3__8 =  s10q8__ 
// g  s10q3__9 =  s10q8__ 
// g s10q3__11 =  s10q8__ 
// g s10q3__12 =  s10q8__ 
// g s10q3__13 =  s10q8__ 
g s10q3__14 =  s10q8__7
g s10q3__15 =  s10q8__8
g s10q3__16 =  s10q8__1
// g s10q3__17 =  s10q8__ 
// g s10q3__18 =  s10q8__ 
// g s10q3__19 =  s10q8__ 
g s10q3__20 = s10q8__12
g s10q3__21 = s10q8__13
g s10q3__96 = s10q8__96
tempfile r16
sa		`r16'


#d ; 
clear; append using
	"${raw_hfps_mwi}/sect10_coping_r2.dta"
	"${raw_hfps_mwi}/sect10_coping_r3.dta"
	"${raw_hfps_mwi}/sect10_coping_r7.dta"
	"${raw_hfps_mwi}/sect10_coping_r15.dta"
	`r16'
	"${raw_hfps_mwi}/sect10_coping_r18.dta"
, gen(round);
#d cr 
isid y4 shock_id round
la drop _append
la val round 
ta round 
replace round=round+1
replace round=round+3 if round>3
replace round=round+7 if round>7
replace round=round+1 if round>16
ta round
assert inlist(round,2,3,7,15,16,18)
	la var round	"Survey round"

	
ta shock_id_os	//	10 copies of each
la li Sec10_shocks__id
la copy Sec10_shocks__id shock_id
la def shock_id 1 "Drought" 2 "Irregular rainfall" 3 "Flooding" 4 "Cyclone", add	//	considered in r18
la def shock_id 14 "Death of Any Other HH member due to COVID-19", add	//	added in round 15 and continued
la val shock_id shock_id 
recode shock_id 95=96	//	different code in round 3, unclear why 
ta shock_id round
tab2 round s10q1 s10q3, first m

egen shock_d_ = rowmin(s10q1 s10q3)
ta shock_id round if shock_d==1

ta shock_id_os if shock_id==96 & shock_d_==1
la li shock_id
*	some of these could be categorized into the categories not asked about. However, can't do mu


*	extent of effect 
*	are s10q2__? categories exclusie? 
la li selection
egen test = rowtotal(s10q2__*)
	ta test round	//	no, not exclusive, and only present in rounds 2&3 
	*	ignore these for the panel 
	drop s10q2__* test
	
*	ignore round 16 specific vars 
	drop s10q3-s10q9
	
	*	make slightly cleaner but leave at shock level, then collapse to hh level in a second step
	g shock_yn = (shock_d_==1) if !mi(shock_d_)
	la var shock_yn	"Affected by shock since last interaction"
	ds s10q3__*, not(type string)
	loc vars `r(varlist)'	//	this is simply automated here, could manually set the order to harmonize later
// 	loc vars s10q3__1 s10q3__6 s10q3__7 s10q3__8 s10q3__9 s10q3__11 s10q3__12 s10q3__13 s10q3__14 s10q3__15 s10q3__16 s10q3__17 s10q3__18 s10q3__19 s10q3__20 s10q3__21 s10q3__22 s10q3__96
	foreach v of local vars {
		loc i = substr("`v'",strpos("`v'","__")+2,length("`v'")-strpos("`v'","__")-1)
		g shock_cope_`i' = `v'
		loc rawlbl : var lab `v'	//	 makes subsequent line shorter to write
		loc stub = substr("`rawlbl'",strpos("`rawlbl'",":")+1,length("`rawlbl'")-strpos("`rawlbl'",":"))
		loc clnlbl = strupper(substr("`stub'",1,1)) + strlower(substr("`stub'",2,length("`stub'")-1))
		la var shock_cope_`i'	"`clnlbl' to cope with shock"
		}
	g shock_cope_os = strtrim(lower(s10q3_os))
	la var shock_cope_os	"Specify other way to cope with shock"

	
	
	
	keep y4_hhid round shock*
	isid y4_hhid round shock_id
	sort y4_hhid round shock_id
	
	*	harmonize shock_code
	run "${hfps_github}/label_shock_code.do"
	la li shock_id shock_code
	g shock_code=shock_id, a(shock_id)
	recode shock_code (1=21)(2=22)(3=23)(4=24)(14=25)(13=1)	
	la val shock_code shock_code
	inspect shock_code
	assert r(N_undoc)==0
	ta shock_id shock_code
	drop shock_id
		
	isid y4_hhid round shock_code
	sort y4_hhid round shock_code
    sa "${local_storage}/tmp_MWI_shocks.dta", replace 
	
*	move to household level for analysis
u  "${local_storage}/tmp_MWI_shocks.dta", clear

ta shock_code
la li shock_code
levelsof shock_code, loc(codes)
foreach c of local codes {
	g shock_yn_`c' = (shock_code==`c' & shock_yn==1) if !mi(shock_yn)
	la var shock_yn_`c'	"`: label (shock_code) `c''"
}
 
*	simply drop the string variables for expediency in the remainder
ds shock*, has(type string)
drop `r(varlist)'

*	verify that missing-ness is intact
tabstat shock_yn_*, by(round) s(n)	//	no missingness as we expect
tabstat shock_cope_*, by(round) s(n)	//	missing shock_cope_17, as we expect (added in round 8 only)


 foreach x of varlist shock_yn* shock_cope* {
 	loc lbl`x' : var lab `x'
 }
collapse (max) shock_yn* shock_cope*, by(y4_hhid round)
 foreach x of varlist shock_yn* shock_cope* {
 	la var `x' "`lbl`x''"
 }

tabstat shock_yn_*, by(round) s(n)	//	no missingness as we expect
tabstat shock_cope_*, by(round) s(n)	//	missing shock_cope_17, as we expect (added in round 8 only)

isid y4_hhid round
sort y4_hhid round
sa "${local_storage}/tmp_MWI_hh_shocks.dta", replace 
	

********************************************************************************
}	/*	Shocks / Coping end	*/ 
********************************************************************************


********************************************************************************
{	/*	label_item	*/ 
********************************************************************************


cap :	program drop	label_item
		program define	label_item
cap : la drop item
#d ; 
la def item 
	102	"maize flour"		/*	lsms code for maize ufa refined, as this is modal option in 2019, though	*/
	104	"maize grain"		
	106	"rice"
	111	"bread"
	121	"sorghum flour"	/*	not an LSMS code	*/

	
	201	"cassava"	
	202	"cassava flour"	
	205	"irish potato"	
	203	"sweet potato"	
	
	
	321	"dry beans"	/*	not an LSMS code	*/
	322	"fresh beans"	/*	not an LSMS code	*/
	305	"groundnut flour"	/*	- pounded gnuts */
	
	408	"tomatoes"
	
	501	"eggs"
	504	"beef"
	
	801	"sugar"
	803	"cooking oil"
	
	6001	"maize seed"
	6002	"soya seed"
	6003	"bean seed"
	
	7001	"petrol"
	7002	"diesel"
	7003	"paraffin"
	7004	"LPG"	/*	liquefied petroleum gas (bottled)	*/
	
	8001	"fuel for car"
	8002	"fuel for motorcycle"
	8003	"transport to nearest market"
	9001	"chemical fertilizer"
	
	
	;
#d cr 
end



********************************************************************************
}	/*	label_item end	*/ 
********************************************************************************


********************************************************************************
{	/*	Price	*/ 
********************************************************************************


dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*prices*", w

d using	"${raw_hfps_mwi}/sect11_foodprices_r15.dta"
d using	"${raw_hfps_mwi}/sect11b_prices_r16.dta"
d using	"${raw_hfps_mwi}/sect11_foodprices_r17.dta"
d using	"${raw_hfps_mwi}/sect11_fuelprices_r17.dta"
d using	"${raw_hfps_mwi}/sect11_transportprices_r17.dta"	//	will ignore this for now

u	"${raw_hfps_mwi}/sect11_foodprices_r15.dta"		, clear
la li fooditems__id
u	"${raw_hfps_mwi}/sect11b_prices_r16.dta"		, clear
la li fooditems__id	// simple shift in code values, easy to modify r15 
u	"${raw_hfps_mwi}/sect11_foodprices_r17.dta"		, clear
la li fooditems__id	//	code shift 
u	"${raw_hfps_mwi}/sect11_fuelprices_r17.dta"		, clear
la li fuel_items__id
u	"${raw_hfps_mwi}/sect11_transportprices_r17.dta", clear	//	will ignore this for now
*	item codes are not harmonized across rounds, necessitating a recode 


u "${raw_lsms_mwi}/hh_mod_g1_19.dta", clear
la li item_labels


u	"${raw_hfps_mwi}/sect11_foodprices_r15.dta"		, clear
la li fooditems__id
la li s11q2
u	"${raw_hfps_mwi}/sect11b_prices_r16.dta"		, clear
la li fooditems__id	// simple shift in code values, easy to modify r15 
la li s11q2	//	transport units added, but also L & KG 




u	"${raw_hfps_mwi}/sect11_fuelprices_r17.dta"		, clear
g item=fuel_id+6991
label_item
la val item item
inspect item
assert r(N_undoc)==0
ta fuel_id item 
la var item	"Item code"

la li s11cq2
g item_avail = inlist(s11cq2,1,2)	//	this is actual purchase here, not truly availability
la var	item_avail	"Item is available for sale"

g price =  s11cq5/s11cq4
la var	price		"Price (LCU/standard unit)"
g unitcost = price	//	in this case we will construct them as identical, though the LCU for total could also be of interest in the price variable
la var	unitcost	"Unit Cost (LCU/unit)"

g unitstr="Litre"
la var unitstr		"Unit"

isid y4_hhid item
keep y4_hhid item item_avail price unitcost unitstr
tempfile fuel
sa		`fuel'

u	"${raw_hfps_mwi}/sect11_foodprices_r17.dta"		, clear
#d ; 
recode food_code 
	(10=104)	/*	maize grain (not ufa)	*/
	(11=106)	/*	rice	*/
	(12=201)	/*	cassava (tubers)	*/
	(13=205)	/*	irish potato	*/
	(14=203)	/*	sweet potato (white flesh)	*/
	(15=102)	/*	maize flour -> coding as ufa refined as this is modal in 2019	*/
	(16=202)	/*	cassava flour	*/
	(17=121)	/*	sorghum flour	*/
	
	(19=321)	/*	dry beans	*/
	(20=322)	/*	fresh beans	*/
	(21=305)	/*	groundnut flour (proxying "Groundnuts (Pounded)") 	*/
	(22=504)	/*	beef	*/
	(24=501)	/*	eggs	*/
	(25=111)	/*	bread	*/
	(27=408)	/*	tomatoes	*/
	(28=801)	/*	sugar	*/
	(29=803)	/*	cooking oil	*/
	, gen(item);
#d cr

label_item
la val item item
inspect item
assert r(N_undoc)==0
ta food_code item 
la var item	"Item code"


g item_avail = (s11q1==1)
la var	item_avail	"Item is available for sale"

ta s11q3	//	just a string
replace s11q3 = strtrim(stritrim(s11q3))
ta s11q3
g inkg = inlist(s11q3,"1 KG","1 KG BAG","1 KILOGRAM","1KG","1KG BAG","1KILOGRAM","KG","KILOGRAM") if !mi(s11q3)
g inl  = inlist(s11q3,"1 LITRE","1LITLER")	 if !mi(s11q3)
	*	ideally this should be restricted on the basis if hwich crops make sense to consider in weight vs volume terms 
ta food_code inkg	//	lots of beef and sugar
ta food_code inl	//	oil only, very good 
compare s11q5 s11q7	//	never jointly defined

ta s11q6
la li s11q6

g price = cond(inkg==1 | inl==1,s11q5,cond(inlist(s11q6,23,24),s11q7,.))
la var price		"Price (LCU/standard unit)"

egen unitcost = rowfirst(s11q5 s11q7)
la var	unitcost	"Unit Cost (LCU/unit)"

*	lacking a conversion factor, we will simply bring the raw unit through 
decode s11q6, gen(xx)
compare s11q3 s11q6	//	substantial jointly defined, rule will be determined by presence of s11q5/7
g unitstr = cond(!mi(s11q5),s11q3,cond(!mi(s11q7),xx,""))
la var unitstr		"Unit"

isid y4_hhid item
keep y4_hhid item item_avail price unitcost unitstr

append using `fuel'
isid y4_hhid item

decode item, gen(itemstr)
la var itemstr	"Item code"

g round=17, b(y4_hhid)
tempfile r17 
sa		`r17'



#d ;
clear; append using 
	"${raw_hfps_mwi}/sect11_foodprices_r15.dta"
	"${raw_hfps_mwi}/sect11b_prices_r16.dta"
	, gen(round); replace round=round+14; la drop _append; la val round; 
replace item_code=food_code+9 if round==15;
recode item_code
	(10=104)	/*	maize grain (not ufa)	*/
	(11=106)	/*	rice	*/
	(12=201)	/*	cassava (tubers)	*/
	(13=205)	/*	irish potato	*/
	(14=203)	/*	sweet potato (white flesh)	*/
	(15=102)	/*	maize flour -> coding as ufa refined as this is modal in 2019	*/
	(16=202)	/*	cassava flour	*/

	(20=7004)	/*	lpg	*/
	(21=7001)	/*	petrol	*/
	(22=7002)	/*	diesel	*/
	(23=7003)	/*	paraffin	*/
	
	(30=9001)	/*	fertilizer	*/
	(31=6001)	/*	maize seed	*/
	(32=6002)	/*	soya seed	*/
	(33=6003)	/*	bean seed	*/
	
	(40=8003)	/*	transport to nearest market	*/
	, gen(item); 
#d cr 
label_item
la val item item
inspect item
assert r(N_undoc)==0
ta item_code item 
la var item	"Item code"

isid y4_hhid item round

decode item, gen(itemstr)
la var itemstr	"Item code"

g item_avail = (s11q0==1)
la var	item_avail	"Item is available for sale"

tabstat s11q3 s11q3_tpt, by(item) s(n)
compare s11q3 s11q3_tpt	//	never jointly defined

recode s11q2 12=96 if round==15
#d ; 	
la def s11q2
		12 "Packet"
		20 "Motor Vehicle"
		21 "Motor Cycle"
		22 "Bicycle"
		23 "Litres"
		24 "Kilogram"
		96 "Other Specify"
	, modify; 
#d cr

g price = s11q3 if inlist(s11q2,23,24)	//	will be no cases in round 15
la var price		"Price (LCU/standard unit)"

g unitcost = s11q3
la var	unitcost	"Unit Cost (LCU/unit)"

*	assess values (briefly)
tabstat price, by(item) s(n me min max) format(%12.3gc)	//	1.5m for 1 kg or cassava?
tabstat unitcost, by(item) s(n me min max) format(%12.3gc)

decode s11q2, gen(unitstr)
la var unitstr		"Unit"

keep  y4_hhid round item itemstr item_avail unitstr price unitcost 
order y4_hhid round item itemstr item_avail unitstr price unitcost
isid  y4_hhid round item
append using `r17'	/*	bring in the round 17 things	*/ 
isid  y4_hhid round item
sort  y4_hhid round item
sa "${local_storage}/tmp_MWI_price.dta", replace 
u  "${local_storage}/tmp_MWI_price.dta", clear 

ta item round

	












********************************************************************************
}	/*	Price end	*/ 
********************************************************************************


********************************************************************************
{	/*	Economic Sentiment	*/ 
********************************************************************************


dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*sentiment*", w
dir "${raw_hfps_mwi}/*nfe*", w

d using	"${raw_hfps_mwi}/sect8c_sentiments_r14.dta"
d using	"${raw_hfps_mwi}/sect8c_sentiments_r16.dta"
d using	"${raw_hfps_mwi}/sect8c_sentiments_r17.dta"


u	"${raw_hfps_mwi}/sect8c_sentiments_r14.dta", clear
la li _all
u	"${raw_hfps_mwi}/sect8c_sentiments_r16.dta", clear
la li _all
u	"${raw_hfps_mwi}/sect8c_sentiments_r17.dta", clear
la li _all

#d ; 
clear; append using
	"${raw_hfps_mwi}/sect8c_sentiments_r14.dta"
	"${raw_hfps_mwi}/sect8c_sentiments_r16.dta"
	"${raw_hfps_mwi}/sect8c_sentiments_r17.dta"
, gen(round);
#d cr 
isid y4 round
la drop _append
la val round 
ta round 
replace round=round+13
replace round=round+1 if round>14
ta round
	la var round	"Survey round"

	

d s8*

la li s9q1 s9q2 s9q3 s9q4 s9q5   s9q7 s9q8 s9q9

ta Sample round,m
tabstat s8q? s8q10__?, by(Sample) s(n)
loc q1 s8q1
ta `q1',m
g sntmnt_last12mohh_label=.
la var sntmnt_last12mohh_label	"Household is financially [...] in past 12 months"
foreach i of numlist 1(1)3 97 {
	loc l=abs(`i')
	g      sntmnt_last12mohh_cat`l' = `q1'==`i' if !mi(`q1')
	la var sntmnt_last12mohh_cat`l' "`: label (`q1') `i''"
}


loc q2	s8q2
ta		`q2', m
g sntmnt_next12mohh_label=.
la var sntmnt_next12mohh_label	"Household will be financially [...] in next 12 months"
foreach i of numlist 1(1)3 97 {
	loc l=abs(`i')
	g      sntmnt_next12mohh_cat`l' = `q2'==`i' if !mi(`q')
	la var sntmnt_next12mohh_cat`l' "`: label (`q2') `i''"
}


loc q3	s8q3
ta		`q3', m
la li	s9q3
g		sntmnt_last12moNtl_label=.
la var	sntmnt_last12moNtl_label	"National economic situation has [...] in past 12 months"
foreach i of numlist 1(1)5 97 {
	loc l=abs(`i')
	g      sntmnt_last12moNtl_cat`l' = `q3'==`i' if !mi(`q3')
	la var sntmnt_last12moNtl_cat`l' "`: label (`q3') `i''"
}

loc q4	s8q4
ta		`q4', m
la li	s9q4
g		sntmnt_next12moNtl_label=.
la var	sntmnt_next12moNtl_label	"National economic situation will [...] in next 12 months"
foreach i of numlist 1(1)5 97 {
	loc l=abs(`i')
	g      sntmnt_next12moNtl_cat`l' = `q4'==`i' if !mi(`q4')
	la var sntmnt_next12moNtl_cat`l' "`: label (`q4') `i''"
}

loc q5	s8q5
ta		`q5', m
la li	s9q5
g      sntmnt_last12moPrice_label=.
la var sntmnt_last12moPrice_label	"Prices have [...] in past 12 months"
foreach i of numlist 1(1)4 97 {
	loc l=abs(`i')
	g      sntmnt_last12moPrice_cat`l' = `q5'==`i' if !mi(`q5')
	la var sntmnt_last12moPrice_cat`l' "`: label (`q5') `i''"
}

loc q6	s8q6
ta		`q6', m
// la li	s9q6
g		sntmnt_last12moPricepct = `q6'
la var	sntmnt_last12moPricepct	"Percent change in prices in past 12 months"

loc q7	s8q7
ta		`q7', m
la li	s9q7
g      sntmnt_next12moPrice_label=.
la var sntmnt_next12moPrice_label	"Prices will [...] in next 12 months"
foreach i of numlist 1(1)5 97 {
	loc l=abs(`i')
	g      sntmnt_next12moPrice_cat`l' = `q7'==`i' if !mi(`q7')
	la var sntmnt_next12moPrice_cat`l' "`: label (`q7') `i''"
}

loc q8	s8q8
ta		`q8', m
la li	s9q8
g      sntmnt_majorpurchase_label=.
la var sntmnt_majorpurchase_label	"The timing is [...] to buy major household items"
foreach i of numlist 1(1)3 97 {
	loc l=abs(`i')
	g      sntmnt_majorpurchase_cat`l' = `q8'==`i' if !mi(`q8')
	loc lbl = subinstr("`: label (`q8') `i''"," time","",1)
	la var sntmnt_majorpurchase_cat`l' "`lbl'"
}

loc q9	s8q9
ta		`q9', m
la li	s9q9
g      sntmnt_weatherrisk_label=.
la var sntmnt_weatherrisk_label	"Financial effects from bad weather events are [...]"
foreach i of numlist 1(1)5 6 {
	loc l=abs(`i')
	g      sntmnt_weatherrisk_cat`l' = `q9'==`i' if !mi(`q9')
	la var sntmnt_weatherrisk_cat`l' "`: label (`q9') `i''"
}

ren sntmnt_weatherrisk_cat6 sntmnt_weatherrisk_cat97



loc weather s8q10__
tabstat `weather'1 `weather'2 `weather'3 `weather'4 `weather'5, by(`q9') s(n)	
d `weather'1 `weather'2 `weather'3 `weather'4 `weather'5

g      sntmnt_weatherevent_label=.
la var sntmnt_weatherevent_label	"Most likely weather event to cause financial effects [...]" 
foreach i of numlist 1(1)5 {
	g	   sntmnt_weatherevent_cat`i' = (`weather'`i'==1) if !mi(`weather'`i')
}
la var sntmnt_weatherevent_cat1		"Drought"
la var sntmnt_weatherevent_cat2		"Delayed rain"
la var sntmnt_weatherevent_cat3		"Floods"
la var sntmnt_weatherevent_cat4		"Heat"
la var sntmnt_weatherevent_cat5		"Storms"
	
su


d sntmnt_*, f
su sntmnt_*, sep(0)


keep y4_hhid round sntmnt_*
isid y4_hhid round
sort y4_hhid round

sa "${local_storage}/tmp_MWI_economic_sentiment.dta", replace 





********************************************************************************
}	/*	Economic Sentiment end	*/ 
********************************************************************************


********************************************************************************
{	/*	Agriculture	*/ 
********************************************************************************


dir "${raw_hfps_mwi}", w
dir "${raw_hfps_mwi}/*_r2.dta", w
dir "${raw_hfps_mwi}/*_r3.dta", w
dir "${raw_hfps_mwi}/*agriculture*", w

d using	"${raw_hfps_mwi}/sect13_agriculture_r1.dta"

d using	"${raw_hfps_mwi}/sect6a_employment1_r2.dta"
d using	"${raw_hfps_mwi}/sect6a_employment1_r3.dta"

d using	"${raw_hfps_mwi}/sect6e_agriculture_r4.dta"
d using	"${raw_hfps_mwi}/sect6e_agriculture_r5.dta"
d using	"${raw_hfps_mwi}/sect6e_agriculture_r6.dta"
d using	"${raw_hfps_mwi}/sect6e_agriculture_r7.dta"
d using	"${raw_hfps_mwi}/sect6e_agriculture_r11.dta"
d using	"${raw_hfps_mwi}/sect6e_agriculture_r12.dta"	

d using	"${raw_hfps_mwi}/sect13_agriculture_r17.dta"
d using	"${raw_hfps_mwi}/sect13_agriculture_r18.dta"


u	"${raw_hfps_mwi}/sect13_agriculture_r1.dta", clear
u	"${raw_hfps_mwi}/sect6a_employment1_r2.dta", clear
u	"${raw_hfps_mwi}/sect6a_employment1_r3.dta", clear

u	"${raw_hfps_mwi}/sect6e_agriculture_r4.dta", clear
u	"${raw_hfps_mwi}/sect6e_agriculture_r5.dta", clear
u	"${raw_hfps_mwi}/sect6e_agriculture_r6.dta", clear
u	"${raw_hfps_mwi}/sect6e_agriculture_r7.dta", clear
u	"${raw_hfps_mwi}/sect6e_agriculture_r11.dta", clear
ta s6eq1,m
la li s6aq13 s6aq15
la li s6aq16
u	"${raw_hfps_mwi}/sect6e_agriculture_r12.dta", clear
ta preload_agric,m

u	"${raw_hfps_mwi}/sect13_agriculture_r17.dta", clear
la li s13q4
la li s13q7
la li s13q8
la li s13q11
u	"${raw_hfps_mwi}/sect13_agriculture_r18.dta", clear
la li s13q8

// ex

#d ; 
clear; append using
	"${raw_hfps_mwi}/sect13_agriculture_r1.dta"
	"${raw_hfps_mwi}/sect6a_employment1_r2.dta"
	"${raw_hfps_mwi}/sect6a_employment1_r3.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r4.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r5.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r6.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r7.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r11.dta"
	"${raw_hfps_mwi}/sect6e_agriculture_r12.dta"
	"${raw_hfps_mwi}/sect13_agriculture_r17.dta"
	"${raw_hfps_mwi}/sect13_agriculture_r18.dta"
	, gen(round);
	la drop _append; la val round .; 
#d cr
replace round = round+3 if round>7
replace round = round+4 if round>12
ta round

*	1	hh grown crops since beginning of agricultural season 
d s13q1 s6q16_1 s6qe1
tab2 round s13q1 s6qe1 s6eq1 preload_agric, m first	// s13 added code 3, but success always = 1
g		ag_refperiod_yn = (s13q1==1) if !mi(s13q1) & inlist(round,1,17,18)
replace ag_refperiod_yn = (s6qe1==1) if !mi(s6qe1) & inlist(round,7)
replace ag_refperiod_yn = (s6eq1==1) if !mi(s6eq1) & inlist(round,11)
	*	Yanick calls for round 12, but the value appears to be pre-loaded and thus hard to see its analytical value separate from the round 11 data
la var ag_refperiod_yn	"Since the beginning of the agricultural season, have you or any member of your household grown crops?"
	
*	3	reason respondent not able to conduct normal farming activities
ta round s6q16_1, m
// g ag_resp_yn = (s6q16_1==1) if !mi(s6q16_1)	//	not called for
d s6q17_1__*
tabstat s6q17_1__*, by(round) s(sum)
g		ag_resp_no_farm_label=.
la var	ag_resp_no_farm_label	"Respondent did not farm normally because [...]"
g		ag_resp_no_farm_cat1 = (s6q17_1__1==1) if !mi(s6q17_1__1)
la var	ag_resp_no_farm_cat1		"Advised to stay home"
g		ag_resp_no_farm_cat2 = (s6q17_1__2==1) if !mi(s6q17_1__2)
la var	ag_resp_no_farm_cat2		"Reduced availability of hired labor"
g		ag_resp_no_farm_cat3 = (s6q17_1__3==1) if !mi(s6q17_1__3)
la var	ag_resp_no_farm_cat3		"Restrictions on movement / travel"
g		ag_resp_no_farm_cat4 = (s6q17_1__4==1) if !mi(s6q17_1__4)
la var	ag_resp_no_farm_cat4		"Unable to acquire / transport inputs"
g		ag_resp_no_farm_cat5 = (s6q17_1__5==1) if !mi(s6q17_1__5)
la var	ag_resp_no_farm_cat5		"Unable to sell / transport outputs"
g		ag_resp_no_farm_cat6 = (s6q17_1__6==1) if !mi(s6q17_1__6)
la var	ag_resp_no_farm_cat6		"Ill / need to care for ill family member"
g		ag_resp_no_farm_cat7 = (s6q17_1__7==1) if !mi(s6q17_1__7)
la var	ag_resp_no_farm_cat7		"Delayed planting / not yet planting season"

*	5	not able to conduct hh ag activities
d s6qe3__*
tabstat s6qe3__*, by(round) s(sum)
d s13q2__*	//	dropped two codes, 1 & 3 from the 
tabstat s13q2__*, by(round) s(sum)
la li selection

g		ag_nogrow_label=.
la var	ag_nogrow_label	"Household did not grow crops because [...]"
g		ag_nogrow_cat1 = (s6qe3__1==1) if !mi(s6qe3__1)
la var	ag_nogrow_cat1		"Advised to stay home"
g		ag_nogrow_cat2 = (s6qe3__2==1) if !mi(s6qe3__2)
replace	ag_nogrow_cat2 = (s13q2__1==1) if !mi(s13q2__1)
la var	ag_nogrow_cat2		"Reduced availability of hired labor"
g		ag_nogrow_cat3 = (s6qe3__3==1) if !mi(s6qe3__3)
la var	ag_nogrow_cat3		"Restrictions on movement / travel"
g		ag_nogrow_cat4a = (s6qe3__4==1) if !mi(s6qe3__4)
replace	ag_nogrow_cat4a = (s13q2__2==1) if !mi(s13q2__2)
la var	ag_nogrow_cat4a		"Unable to acquire / transport seeds"
g		ag_nogrow_cat4b = (s6qe3__5==1) if !mi(s6qe3__5)
replace	ag_nogrow_cat4b = (s13q2__3==1) if !mi(s13q2__3)
la var	ag_nogrow_cat4b		"Unable to acquire / transport fertilizer"
g		ag_nogrow_cat4c = (s6qe3__6==1) if !mi(s6qe3__6)
replace	ag_nogrow_cat4c = (s13q2__4==1) if !mi(s13q2__4)
la var	ag_nogrow_cat4c		"Unable to acquire / transport other inputs"
egen	ag_nogrow_cat4 = rowmax(ag_nogrow_cat4a ag_nogrow_cat4b ag_nogrow_cat4c)
la var	ag_nogrow_cat4		"Unable to acquire / transport inputs"
g		ag_nogrow_cat5 = (s6qe3__7==1) if !mi(s6qe3__7)
replace	ag_nogrow_cat5 = (s13q2__5==1) if !mi(s13q2__5)
la var	ag_nogrow_cat5		"Unable to sell / transport outputs"
g		ag_nogrow_cat6 = (s6qe3__8==1) if !mi(s6qe3__8)
replace	ag_nogrow_cat6 = (s13q2__6==1) if !mi(s13q2__6)
la var	ag_nogrow_cat6		"Ill / need to care for ill family member"
g		ag_nogrow_cat7 = (s6qe3__9==1) if !mi(s6qe3__9)
replace	ag_nogrow_cat7 = (s13q2__7==1) if !mi(s13q2__7)
la var	ag_nogrow_cat7		"Delayed planting / not yet planting season"
	*	ignore the o/s

*	6	not able to access fertilizer 
	d s13q3 s6qe8__*
tab2 round s13q3 //	our data is in r17 
tabstat s6qe8__*, by(round) s(sum count)
g		ag_nofert_label=.
la var	ag_nofert_label	"Household could not access/transport fertilizer because [...]"
g		ag_nofert_cat1=(s6qe8__1==1 |  s6qe8__2==1 | s13q3==1)	if !mi(s6qe8__1) | !mi(s6qe8__2) | (!mi(s13q3) & round==17)
la var	ag_nofert_cat1	"No supply of fertilizer"
g		ag_nofert_cat2=(s6qe8__6==1 | s13q3==2)	if !mi(s6qe8__6) | (!mi(s13q3) & round==17)
la var	ag_nofert_cat2	"Too expensive / not enough money to buy"
g		ag_nofert_cat3=(s6qe8__3==1 |  s6qe8__4==1)	if !mi(s6qe8__3) | !mi(s6qe8__4)
la var	ag_nofert_cat3	"Unable to travel / transport fertilizer"
g		ag_nofert_cat4=(s6qe8__5==1)	if !mi(s6qe8__5)
la var	ag_nofert_cat4	"Increase in price of fertilizer"


*	7	main crop 
tab2 round s13q2a s13q2b s13q2c,first	//	round 1 only
tabstat s13q2?, by(round) s(count)
la li crops
// recode s13q2a s13q2b s13q2c (1/4=1)(5/10=5)(11/16=11)(17/26=17), copyrest gen(r1_crop1 r1_crop2 r1_crop3)

ta s6eq5 round	//	r11 only
ta s6eq5_ot 
la li s6aq5	//	truncated value label
ta s6aq5 round	//	r12 only

ta s13q4 round	//	rounds 17 & 18 (not round 1)
la li crops s6aq5	//	truncated value label

g 		cropcode = s13q2a if round==1
replace cropcode = s6eq5  if round==11
replace cropcode = s6aq5  if round==12
replace cropcode = s13q4  if inlist(round,17,18)
la var cropcode	"Main crop code"


*	8	harvesting complete
tab2 round s13q3 s6eq8 s6eq16 s6aq6 s13q8_1, first
la li s13q3 
g		ag_harv_complete = . 
replace	ag_harv_complete = s13q3==3		if round==1  & !mi(s13q3)
replace	ag_harv_complete = s6eq16==1	if round==11 & !mi(s6eq16)
replace	ag_harv_complete = s6aq6==1		if round==12 & !mi(s6aq6)
replace	ag_harv_complete = s13q8_1==1	if round==18 & !mi(s13q8_1)
la var	ag_harv_complete	"Harvest of main crop complete"

*	9	planting complete
ta s13q5 round
g		ag_plant_complete = (s13q5==1) if round==17 & !mi(s13q5)
la var	ag_plant_complete	"Planting of main crop complete"


*	10 area planted
ta s6eq7_units round
ta s6eq7_units_ot
li s6eq6 s6eq7 s6eq7_units s6eq7_units_ot if !mi(s6eq7_units_ot)
la li s6aq7_units
recode s6eq7_units (96=3) 		if s6eq7_units_ot=="70 by 70 square meters each plot"
replace s6eq7 = 70 * 70 * s6eq6	if s6eq7_units_ot=="70 by 70 square meters each plot"  
g		ag_plant_ha = s6eq7 if s6eq7_units==2	//	hectares
replace ag_plant_ha = s6eq7 * 0.40468564224 if s6eq7_units==1	//	acres
replace ag_plant_ha = s6eq7 * 0.0001 if s6eq7_units==3		//	square meters

ta s13q6b round
ta s13q6b_oth	//	"plot"
replace ag_plant_ha = s13q6a if s13q6b==2	//	hectares
replace ag_plant_ha = s13q6a * 0.40468564224 if s13q6b==1	//	acres
replace ag_plant_ha = s13q6a * 0.0001 if s13q6b==3		//	square meters
la var ag_plant_ha	"Hectares planted with main crop"

*	11	area comparison to last planting
ta s13q7 round
g ag_plant_vs_prior=s13q7 if round==17
#d ; 
la def ag_plant_vs_prior 
           1 "Much more (<25% or more area)"
           2 "Somewhat more (5-25% more)"
           3 "About the same (+/- 5%)"
           4 "Somewhat less (5-25% less)"
           5 "Much less (>25% less)"
           6 "Not applicable (e.g. did not plant this crop last year)"
		;
#d cr 
la val ag_plant_vs_prior ag_plant_vs_prior
la var ag_plant_vs_prior	"Comparative planting area vs last planting"

*	12	harvest expectation ex ante
ta s13q8 round
g ag_anteharv_subj=s13q8 if round==17
la var ag_anteharv_subj	"Subjective assessment of harvest ex-ante"

*	12b harvest assessment ex post
g ag_postharv_subj=s13q8 if round==18
la var ag_postharv_subj	"Subjective assessment of harvest ex-post"
#d ; 
la def ag_subjective_assessment
           1 "Exceptionally good / much better than normal"
           2 "Good / better than normal"
           3 "Average / normal"
           4 "Not good, less than normal"
           5 "Very bad, much less than normal"
		   ;
#d cr
la val ag_????harv_subj ag_subjective_assessment

*	13	expected harvest quantity
ta s13q9 round
ta s13q9b round
// dir "${raw_lsms_mwi}"
// d using "${raw_lsms_mwi}/ihs_seasonalcropconversion_factor_2020.dta"
// d using "${local_storage}/tmp_MWI_pnl_cover.dta"
// mer 1:1 y4 round using "${local_storage}/tmp_MWI_cover.dta", keepus(hh_a00)	
g		ag_anteharv_q		= s13q9			if round==17
g		ag_anteharv_u		= s13q9b		if round==17
g		ag_anteharv_u_os	= s13q9b_oth	if round==17
replace	ag_anteharv_q		= s13q9_1		if round==18
replace	ag_anteharv_u		= s13q9b_1		if round==18
replace	ag_anteharv_u_os	= s13q9b_oth_1	if round==18
replace	ag_anteharv_q		= s6eq17a		if round==11
replace	ag_anteharv_u		= s6eq17b		if round==11
g		ag_anteharv_c		= s6eq17c		if round==11
la var	ag_anteharv_q		"Expected harvest quantity"
la var	ag_anteharv_u		"Expected harvest unit"
la var	ag_anteharv_u_os	"Expected harvest unit o/s"
la var	ag_anteharv_c		"Expected harvest condition"
	
*	14	actual harvest quantity
g		ag_postharv_q		= s13q9			if round==18
g		ag_postharv_u		= s13q9b		if round==18
g		ag_postharv_u_os	= s13q9b_oth	if round==18
replace	ag_postharv_q		= s6eq9a		if round==11
replace	ag_postharv_u		= s6eq9b		if round==11
replace	ag_postharv_u_os	= s6eq9b_ot		if round==11
g		ag_postharv_c		= s6eq9c		if round==11
la var	ag_postharv_q		"Completed harvest quantity"
la var	ag_postharv_u		"Completed harvest unit"
la var	ag_postharv_u_os	"Completed harvest unit o/s"
la var	ag_postharv_c		"Completed harvest condition"
	
compare ag_anteharv_q ag_postharv_q if round==18	//	exclusive
compare ag_anteharv_q ag_postharv_q if round==11	//	not exclusive

*	15	normally sell
ta s13q10 round
tab2 round s6eq13 s6eq15,first m
g		ag_sale_typical	= s13q10==1 if !mi(s13q10) & inlist(round,17,18)
replace ag_sale_typical = (s6eq13==99 & inlist(s6eq15,99,.)) if !mi(s6eq13) & round==11
replace ag_sale_typical = (s6eq15==99 & inlist(s6eq13,99,.)) if !mi(s6eq15) & round==11
la var	ag_sale_typical		"Main crop is typically marketed"

*	16	current marketing
ta s6eq10 round
g ag_sale_current = (s6eq10==1) if !mi(s6eq10) & round==11

*	17	Pre-sale subjective assessment
ta s13q11 round
ta s13q11_1 round
ta s6eq15 round
g		ag_antesale_subj = s13q11 if round==17
replace	ag_antesale_subj = s13q11_1 if round==18
replace	ag_antesale_subj = s6eq15 if round==11 & inrange(s6eq15,1,5)
la var	ag_antesale_subj	"Subjective assessment of expected sales revenues"
la val	ag_antesale_subj ag_subjective_assessment

*	17a	Post-sale subjective assessment
ta s13q11 round
ta s6eq13 round
g		ag_postsale_subj = s13q11 if round==18
replace	ag_postsale_subj = s13q11_1 if round==18
replace	ag_postsale_subj = s6eq13 if round==11 & inrange(s6eq13,1,5)
la var	ag_postsale_subj	"Subjective assessment of completed sales revenues"
la val	ag_postsale_subj ag_subjective_assessment

*	18	why harvest low/high/etc

*	19	inorg fertilizer dummy
ta s13q12 round
tab2 round s6eq18?, first 
g		ag_inorgfert_post = (s13q12==1) if !mi(s13q12)	//	no round requirement necessary
replace	ag_inorgfert_post = (s6eq18a==1) if !mi(s6eq18a)
la var	ag_inorgfert_post		"Applied any inorganic fertilizer this season"

g		ag_orgfert_post = (s6eq18b==1) if !mi(s6eq18b)
la var	ag_orgfert_post	"Applied any organic fertilizer this season"
g		ag_pesticide_post = (s6eq18c==1) if !mi(s6eq18c)
la var	ag_pesticide_post	"Applied any pesticide / herbicide this season"
g		ag_hirelabor_post = (s6eq18d==1) if !mi(s6eq18d)
la var	ag_hirelabor_post	"Applied any hired labor this season"
g		ag_draught_post = (s6eq18e==1) if !mi(s6eq18e)
la var	ag_draught_post	"Applied any animal traction this season"

*	20	future fertilizer 
ta s13q14 round
g		ag_inorgfert_ante = (s13q14==1) if round==17 & !mi(s13q14)
la var	ag_inorgfert_ante	"Intend to apply inorganic fertilizer this season"

*	21	SKIPPING FERTILIZER TYPES FOR NOW, want to see codes in other surveys first 

*	22	Q of input not available

*	23 reason no [input]
ta s13q16 round
tabstat s6eq19a__*, s(sum) by(round)
tab1 s6eq19?_ot	//	many of these should be a coded response, particularly the org fert-> not available 
la li s13q16
d s6eq19a__*	
g		ag_inorgfert_no_label=.
la var	ag_inorgfert_no_label	"Did not apply inorganic fertilizer because [...]"
g 		ag_inorgfert_no_cat1 = (s6eq19a__7==1) if !mi(s6eq19a__7)
replace ag_inorgfert_no_cat1 = (inlist(s13q16,1,2)) if !mi(s13q16)
la var	ag_inorgfert_no_cat1	"Did not need"
g 		ag_inorgfert_no_cat2 = (s6eq19a__5==1 | s6eq19a__6==1) if !mi(s6eq19a__5,s6eq19a__6)
replace ag_inorgfert_no_cat2 = (inlist(s13q16,3)) if !mi(s13q16)
la var	ag_inorgfert_no_cat2	"Too expensive / could not afford"
g 		ag_inorgfert_no_cat3 = (s6eq19a__1==1 | s6eq19a__2==1) if !mi(s6eq19a__1,s6eq19a__2)
replace ag_inorgfert_no_cat3 = (inlist(s13q16,4)) if !mi(s13q16)
la var	ag_inorgfert_no_cat3	"Not available"
g 		ag_inorgfert_no_cat4 = (s6eq19a__3==1 | s6eq19a__4==1) if !mi(s6eq19a__3,s6eq19a__4)
// replace ag_inorgfert_no_cat4 = (inlist(s13q16,4)) if !mi(s13q16)
la var	ag_inorgfert_no_cat4	"Unable to travel / transport"

g		ag_orgfert_no_label=.
la var	ag_orgfert_no_label	"Did not apply organic fertilizer because [...]"
g 		ag_orgfert_no_cat1 = (s6eq19b__7==1) if !mi(s6eq19b__7)
la var	ag_orgfert_no_cat1	"Did not need"
g 		ag_orgfert_no_cat2 = (s6eq19b__5==1 | s6eq19b__6==1) if !mi(s6eq19b__5,s6eq19b__6)
la var	ag_orgfert_no_cat2	"Too expensive / could not afford"
g 		ag_orgfert_no_cat3 = (s6eq19b__1==1 | s6eq19b__2==1 | s6eq19b__96==1) if !mi(s6eq19b__1,s6eq19b__2)
la var	ag_orgfert_no_cat3	"Not available"
g 		ag_orgfert_no_cat4 = (s6eq19b__3==1 | s6eq19b__4==1) if !mi(s6eq19b__3,s6eq19b__4)
la var	ag_orgfert_no_cat4	"Unable to travel / transport"

g		ag_pesticide_no_label=.
la var	ag_pesticide_no_label	"Did not apply pesticide / herbicide because [...]"
g 		ag_pesticide_no_cat1 = (s6eq19c__7==1) if !mi(s6eq19c__7)
la var	ag_pesticide_no_cat1	"Did not need"
g 		ag_pesticide_no_cat2 = (s6eq19c__5==1 | s6eq19c__6==1) if !mi(s6eq19c__5,s6eq19c__6)
la var	ag_pesticide_no_cat2	"Too expensive / could not afford"
g 		ag_pesticide_no_cat3 = (s6eq19c__1==1 | s6eq19c__2==1) if !mi(s6eq19c__1,s6eq19c__2)
la var	ag_pesticide_no_cat3	"Not available"
g 		ag_pesticide_no_cat4 = (s6eq19c__3==1 | s6eq19c__4==1) if !mi(s6eq19c__3,s6eq19c__4)
la var	ag_pesticide_no_cat4	"Unable to travel / transport"

g		ag_hirelabor_no_label=.
la var	ag_hirelabor_no_label	"Did not hire any labor because [...]"
g 		ag_hirelabor_no_cat1 = (s6eq19d__7==1) if !mi(s6eq19d__7)
la var	ag_hirelabor_no_cat1	"Did not need"
g 		ag_hirelabor_no_cat2 = (s6eq19d__2==1 | s6eq19d__5==1 | s6eq19d__96==1) if !mi(s6eq19d__2,s6eq19d__5,s6eq19d__96)
la var	ag_hirelabor_no_cat2	"Too expensive / could not afford"
g 		ag_hirelabor_no_cat3 = (s6eq19d__1==1 | s6eq19d__3==1) if !mi(s6eq19d__1,s6eq19d__3)
la var	ag_hirelabor_no_cat3	"Not available"
g 		ag_hirelabor_no_cat4 = (s6eq19d__4==1) if !mi(s6eq19d__4)
la var	ag_hirelabor_no_cat4	"Unable to travel / transport"

g		ag_draught_no_label=.
la var	ag_draught_no_label	"Did not use animal traction because [...]"
g 		ag_draught_no_cat1 = (s6eq19e__7==1) if !mi(s6eq19e__7)
la var	ag_draught_no_cat1	"Did not need"
g 		ag_draught_no_cat2 = (s6eq19e__2==1 | s6eq19e__5==1 | s6eq19e__6==1 | (s6eq19e__96==1 &  inlist(s6eq19e_ot,"its expensive","lack of money"))) if !mi(s6eq19e__2,s6eq19e__5,s6eq19e__96)
la var	ag_draught_no_cat2	"Too expensive / could not afford"
g 		ag_draught_no_cat3 = (s6eq19e__1==1 | s6eq19e__3==1 | (s6eq19e__96==1 & !inlist(s6eq19e_ot,"its expensive","lack of money"))) if !mi(s6eq19e__1,s6eq19e__3,s6eq19e__96)
la var	ag_draught_no_cat3	"Not available"
g 		ag_draught_no_cat4 = (s6eq19e__4==1) if !mi(s6eq19e__4)
la var	ag_draught_no_cat4	"Unable to travel / transport"

*	24 q purchased

*	25 Acquire full amount? 
ta s13q17 round
g ag_fertilizer_fullq = (s13q17==1) if !mi(s13q17)
la var ag_fertilizer_fullq	"Able to buy desired quantity of fertilizer"

*	26	how much more still desired? 

*	27	Why unable to acquire enough fert

*	28	Adaptations for fertilizer issue
ta s13q18 round
li s13q18_oth if s13q18==4, sep(0)
recode s13q18 (4=1) if inlist(s13q18_oth,"apply part of the garden the other part was not applied",	/*
*/	"applied fertiliser half of the cultivated area",	/*
*/	"applied other part left other part un applied",	/*
*/	"applied on other part","applied  one part")

recode s13q18 (4=2) if inlist(s13q18_oth,"The whole plot by scattering",	/*
*/	"didn't apply")
replace s13q18_oth="" if s13q18!=4

g		ag_nofert_adapt_label=.
la var	ag_nofert_adapt_label	"Adapted to inorganic fertilizer limitation by [...]"
g		ag_nofert_adapt_cat1=(s13q18==1) if !mi(s13q18)
la var	ag_nofert_adapt_cat1	"Only fertilized part of cultivated area"
g		ag_nofert_adapt_cat2=(s13q18==2) if !mi(s13q18)
la var	ag_nofert_adapt_cat2	"Used lower rate of fertilizer"
g		ag_nofert_adapt_cat3=(s13q18==3) if !mi(s13q18)
la var	ag_nofert_adapt_cat3	"Cultivated a smaller area"
g		ag_nofert_adapt_cat4=(s13q18==4) if !mi(s13q18)	//	imperfect but fairly close following cleaning 
la var	ag_nofert_adapt_cat4	"Supplemented with organic fertilizer"


*	29	price of fertilizer
ta s13q19a round	//	type	(ignore for now)
ta s13q19c round	//	u
g		ag_fertcost1_type	= s13q19a if !mi(s13q19a) & !mi(s13q19c) & !mi(s13q19b)
g		ag_fertcost1_unit	= s13q19c if !mi(s13q19a) & !mi(s13q19c) & !mi(s13q19b)
g		ag_fertcost1_lcu	= s13q19b if !mi(s13q19a) & !mi(s13q19c) & !mi(s13q19b)
g		ag_fertcost2_type	= s13q20a if !mi(s13q20a) & !mi(s13q20c) & !mi(s13q20b)
g		ag_fertcost2_unit	= s13q20c if !mi(s13q20a) & !mi(s13q20c) & !mi(s13q20b)
g		ag_fertcost2_lcu	= s13q20b if !mi(s13q20a) & !mi(s13q20c) & !mi(s13q20b)

*	no conversion for now


*	30	
*	31

keep  y4_hhid round ag_* cropcode
isid  y4_hhid round
sort  y4_hhid round
sa "${local_storage}/tmp_MWI_agriculture.dta", replace 
u  "${local_storage}/tmp_MWI_agriculture.dta", clear 























********************************************************************************
}	/*	Agriculture end	*/ 
********************************************************************************

ex

********************************************************************************
{	/*		*/ 
********************************************************************************

********************************************************************************
}	/*	end	*/ 
********************************************************************************


